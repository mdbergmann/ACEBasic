Phase 2 (BIND/Closures) -- Implementation State
=================================================
Date: 2026-01-27
Status: CODE COMPLETE -- awaiting build and emulator verification

Completed Steps
---------------
1. Added `bindsym` to ACE reserved word enum in acedef.h:298
   (between binstrsym and blocksym)

2. Added "BIND" to rword[] array in lexvar.c:99
   (between "BIN$" and "BLOCK")

3. Added `int last_bind_bound_count = 0;` to parsevar.c:205
   (after last_addr_sub_sym declaration)

4. Implemented BIND in basfun.c:
   - Added `case bindsym : return(TRUE);` to numfunc() (between allocsym and atnsym)
   - Added `extern int last_bind_bound_count;` and `extern int addr[];` to externals
   - Implemented BIND case in numericfunction() (~80 lines at line 903-1004)
   - Uses `lev == 0 ? "(a4)" : "(a5)"` for frame pointer (since basfun.c
     has addreg[] = {"a4","a5"} without parens, not frame_ptr)

5. Updated assign.c:
   - Added `extern int last_bind_bound_count;` to externals (line 80)
   - Modified variable assignment linkage (line 494) to store dims:
       if (last_addr_sub_sym != NULL && storage_item->type == longtype)
       {
          storage_item->other = last_addr_sub_sym;
          storage_item->dims = last_bind_bound_count;
       }
       last_addr_sub_sym = NULL;
       last_bind_bound_count = 0;

6. Extended INVOKE in factor.c for closure dispatch:
   - Added `extern int addr[];` to externals (line 73)
   - Added closure dispatch path (dims > 0) BEFORE the existing SUB
     convention check (lines 421-595)
   - Compile-time dispatch: no runtime magic check, uses dims > 0
   - Parses free args from source, reads bound args from closure record
   - Uses load_params-style Forbid/copy pattern for frame setup
   - Reloads a2 from variable before calling through 4(a2)
   - Tracks `had_parens` flag for correct insymbol() at end
   - Pushes return value same as existing SUB convention path

7. Extended INVOKE in statement.c for closure dispatch:
   - Added `extern int addr[];` to externals (line 86)
   - Added closure dispatch path (dims > 0) BEFORE the existing SUB
     convention check (lines 719-830)
   - Same as factor.c but without return value pushing

8. Created test programs:
   - verify/tests/cases/closures/bind_one_arg.b (expected: 15)
   - verify/tests/cases/closures/bind_multi_arg.b (expected: 33)
   - verify/tests/cases/closures/bind_in_sub.b (expected: 15)
   - Plus corresponding .expected files in verify/tests/expected/

Files Modified
--------------
| File | Change |
|------|--------|
| src/ace/c/acedef.h:298 | `bindsym` in enum (done in prior session) |
| src/ace/c/lexvar.c:99 | `"BIND"` in rword[] (done in prior session) |
| src/ace/c/parsevar.c:205 | `int last_bind_bound_count = 0;` |
| src/ace/c/basfun.c:71-73 | extern declarations for addr[], last_bind_bound_count |
| src/ace/c/basfun.c:768 | `case bindsym` in numfunc() |
| src/ace/c/basfun.c:903-1004 | BIND implementation in numericfunction() |
| src/ace/c/assign.c:80 | extern int last_bind_bound_count |
| src/ace/c/assign.c:494 | Store dims from last_bind_bound_count |
| src/ace/c/factor.c:73 | extern int addr[] |
| src/ace/c/factor.c:421-595 | Closure dispatch in INVOKE (expression) |
| src/ace/c/statement.c:86 | extern int addr[] |
| src/ace/c/statement.c:719-830 | Closure dispatch in INVOKE (statement) |

Closure Record Layout (as implemented)
---------------------------------------
Offset  Size  Field
------  ----  -----
0       4     Magic marker 0x434C5352 ("CLSR")
4       4     Function pointer (address of _SUB_name)
8       2     Total param count of the SUB
10      2     Number of bound arguments
12      N*4   Bound arg values (all stored as 4 bytes)

Total size: 12 + N*4 bytes where N = bound argument count.

All bound args stored as 4-byte values for uniformity:
- LONGINT/ADDRESS: stored directly
- SHORTINT: sign-extended to long at BIND time, truncated at INVOKE time
- SINGLE: stored directly (same 4-byte IEEE representation)
- STRING: string ADDRESS stored (no deep copy -- known limitation)

Key Design Decisions (as implemented)
--------------------------------------
1. COMPILE-TIME DISPATCH: dims > 0 means closure, dims == 0 means raw pointer.
   No runtime magic check needed.

2. BOUND ARGS ARE FIRST: BIND(@Sub, a, b) binds parameters 0..N-1.
   Free args at INVOKE fill positions N..total-1.

3. UNIFORM 4-BYTE STORAGE: Simplifies record layout. Type conversion at
   BIND (short->long extend) and INVOKE (long->short truncate for frame).

4. basfun.c uses `lev == 0 ? "(a4)" : "(a5)"` inline instead of adding a
   static frame_ptr[] array, since addreg[] already exists without parens.

5. INVOKE closure dispatch uses `had_parens` flag to correctly handle
   insymbol() -- avoids skipping a token when no parens are present
   (e.g., all args bound, no free args, no parens written).

Known Limitations
-----------------
1. PASSED CLOSURES: When a closure is passed as a LONGINT parameter to
   another SUB, the `other` and `dims` linkage is lost. INVOKE inside
   that SUB will use MC convention, which won't dispatch correctly.
   This is a known Phase 2 limitation.

2. STRING VALUE CAPTURE: BIND captures string addresses, not string
   content. If the source string's BSS storage is reused (e.g., after
   the enclosing SUB returns), the closure may hold a stale pointer.

3. NO INDIVIDUAL FREE: Closure records are ACEalloc'd and freed at
   program exit. Closures created in tight loops will accumulate memory.

Remaining Work
--------------
1. Build on Amiga emulator:
   cd src/make && make -f Makefile-ace clean && make -f Makefile-ace

2. Verify no regressions by compiling existing programs (HelloWorld,
   Screen, SleepFor) and diffing .s output against pre-change baselines.

3. Run Phase 2 test programs on emulator:
   rx verify/tests/runner.rexx closures

4. Phase 3 (Documentation) can then proceed per the implementation plan.
